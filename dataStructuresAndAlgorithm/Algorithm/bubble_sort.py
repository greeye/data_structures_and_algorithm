
# coding: utf-8

# # 冒泡排序
# **重复地遍历需要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来**
# 
# 步骤：
# - 比较**相邻的元素**，**如果第一个比第二个大(升序)，就交换他们两个**
# - 对**每一对相邻元素**作同样的工作，从开始第一个队到结尾的最后一对，这步做完后，最后的元素会是最大的数。
# - 针对所有的元素重复以上的步骤，除了最后一个(最后一个元素已经)
# - 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要进行调换位置

# In[4]:


def bubble_sort(alist):
    for j in range(len(alist)-1,0,-1):
        # j 表示 每次遍历需要比较的次数，是逐渐减少的
        for i in range(j):
            if i in range(j):
                if alist[i] > alist[i+1]:
                    alist[i],alist[i+1] = alist[i+1],alist[i]


# In[5]:


li = [64,26,93,17,31,44,55,20]


# In[6]:


bubble_sort(li)


# In[7]:


print(li)


# In[ ]:


** 时间复杂度 **

